{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "mentoring-adf-lm"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/M8_populate_Fact_tables')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "sql_movies_Database",
								"type": "DatasetReference"
							},
							"name": "tOnlinePurchase"
						},
						{
							"dataset": {
								"referenceName": "sql_movies_Database",
								"type": "DatasetReference"
							},
							"name": "tOnlinePurchaseMonthly"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sql_FactOnlinePurchase_table",
								"type": "DatasetReference"
							},
							"name": "sinkFactOnlinePurchase"
						},
						{
							"dataset": {
								"referenceName": "sql_FactOnlinePurchaseMonthly",
								"type": "DatasetReference"
							},
							"name": "FactOnlinePurchaseMonthlySnapshot"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT\\n     FORMAT(OP.TransactionDate, \\'yyyyMMdd\\') AS DateKey,\\n     OS.ServiceId AS OnlineServiceKey,\\n     TM.MovieId AS MovieKey,\\n     OP.Price,\\n     OP.TransactionId\\nFROM [dbo].[tOnlinePurchase] OP JOIN [dbo].[tOnlineService] OS\\nON OP.ServiceId = OS.ServiceId\\nJOIN [dbo].[tMovies] TM\\nON OP.MovieId = TM.MovieId',",
						"     format: 'query') ~> tOnlinePurchase",
						"source(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT\\n     FORMAT(OP.TransactionDate, \\'yyyyMM\\') AS MonthKey, \\n     OS.ServiceId AS OnlineServiceKey, \\n     SUM(OP.Price) AS PurchaseAmount, \\n     COUNT(OP.TransactionId) AS PurchaseQuantity \\nFROM [dbo].[tOnlinePurchase] OP JOIN [dbo].[tOnlineService] OS\\nON OP.ServiceId = OS.ServiceId\\nGROUP BY FORMAT(TransactionDate, \\'yyyyMM\\'), OS.ServiceId',",
						"     format: 'query') ~> tOnlinePurchaseMonthly",
						"tOnlinePurchase sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          DateKey as integer,",
						"          OnlineServiceKey as integer,",
						"          MovieKey as integer,",
						"          Price as decimal(4,1),",
						"          TransactionId as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkFactOnlinePurchase",
						"tOnlinePurchaseMonthly sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          MonthKey as integer,",
						"          OnlineServiceKey as integer,",
						"          PurchaseAmount as decimal(10,1),",
						"          PurchaseQuantity as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> FactOnlinePurchaseMonthlySnapshot"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/M8_populate_Fact_tables_2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "sql_movies_tOnlinePurchase",
								"type": "DatasetReference"
							},
							"name": "tOnlinePurchase"
						},
						{
							"dataset": {
								"referenceName": "sql_DataMart_DimOnlineService",
								"type": "DatasetReference"
							},
							"name": "DimOnlineService"
						},
						{
							"dataset": {
								"referenceName": "sql_DataMart_DimMovie",
								"type": "DatasetReference"
							},
							"name": "DimMovie"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sql_FactOnlinePurchase_table",
								"type": "DatasetReference"
							},
							"name": "sinkFactOnlinePurchase"
						},
						{
							"dataset": {
								"referenceName": "sql_FactOnlinePurchaseMonthly",
								"type": "DatasetReference"
							},
							"name": "FactOnlinePurchaseMonthlySnapshot"
						}
					],
					"transformations": [
						{
							"name": "JoinOnlineService"
						},
						{
							"name": "DailyDate"
						},
						{
							"name": "MonthlyDate"
						},
						{
							"name": "AggregatedColumns"
						},
						{
							"name": "JoinMovie"
						}
					],
					"scriptLines": [
						"source(output(",
						"          TransactionDate as timestamp,",
						"          ServiceCode as string,",
						"          ServiceName as string,",
						"          MovieIdNK as integer,",
						"          Price as decimal(4,1),",
						"          TransactionId as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT\\n     OP.TransactionDate,\\n     OS.ServiceCode,\\n      OS.ServiceName,\\n     TM.MovieIdNK,\\n     OP.Price,\\n     OP.TransactionId\\nFROM [dbo].[tOnlinePurchase] OP JOIN [dbo].[tOnlineService] OS\\nON OP.ServiceId = OS.ServiceId\\nJOIN [dbo].[tMovies] TM\\nON OP.MovieId = TM.MovieId',",
						"     format: 'query') ~> tOnlinePurchase",
						"source(output(",
						"          ServiceKey as integer,",
						"          ServiceCode as string,",
						"          ServiceName as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT\\n     ServiceKey,\\n     ServiceCode,\\n     ServiceName\\nFROM [dbo].[DimOnlineService]',",
						"     format: 'query') ~> DimOnlineService",
						"source(output(",
						"          MovieKey as integer,",
						"          DIM_MovieIdNK as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     batchSize: 0,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT\\n     MovieKey,\\n     MovieIdNK AS DIM_MovieIdNK\\nFROM [dbo].[DimMovie]',",
						"     format: 'query') ~> DimMovie",
						"tOnlinePurchase, DimOnlineService join(tOnlinePurchase@ServiceCode == DimOnlineService@ServiceCode",
						"     && tOnlinePurchase@ServiceName == DimOnlineService@ServiceName,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOnlineService",
						"JoinOnlineService derive(TransactionDate = toString(TransactionDate, 'yyyyMMdd')) ~> DailyDate",
						"JoinOnlineService derive(MonthKey = toString(TransactionDate, 'yyyyMM')) ~> MonthlyDate",
						"MonthlyDate aggregate(groupBy(MonthKey,",
						"          ServiceKey),",
						"     PurchaseAmount = sum(Price),",
						"          PurchaseQuantity = count(MonthKey)) ~> AggregatedColumns",
						"DailyDate, DimMovie join(MovieIdNK == DIM_MovieIdNK,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinMovie",
						"JoinMovie sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          DateKey as integer,",
						"          OnlineServiceKey as integer,",
						"          MovieKey as integer,",
						"          Price as decimal(4,1),",
						"          TransactionId as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          DateKey = TransactionDate,",
						"          OnlineServiceKey = ServiceKey,",
						"          MovieKey,",
						"          Price,",
						"          TransactionId",
						"     )) ~> sinkFactOnlinePurchase",
						"AggregatedColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          MonthKey as integer,",
						"          OnlineServiceKey as integer,",
						"          PurchaseAmount as decimal(10,1),",
						"          PurchaseQuantity as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          MonthKey,",
						"          OnlineServiceKey = ServiceKey,",
						"          PurchaseAmount,",
						"          PurchaseQuantity",
						"     )) ~> FactOnlinePurchaseMonthlySnapshot"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/M8_populate_dim_tables')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "sql_tMovies_Table",
								"type": "DatasetReference"
							},
							"name": "tMovies"
						},
						{
							"dataset": {
								"referenceName": "sql_tMovieStatus_Table",
								"type": "DatasetReference"
							},
							"name": "tMoviesStatus"
						},
						{
							"dataset": {
								"referenceName": "sql_movies_OnlineService",
								"type": "DatasetReference"
							},
							"name": "tOnlineService"
						},
						{
							"dataset": {
								"referenceName": "sql_DataMart_DimOnlineService",
								"type": "DatasetReference"
							},
							"name": "sourceDimOnlineService"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sql_DataMart_DimMovie",
								"type": "DatasetReference"
							},
							"name": "sinkDimMovie"
						},
						{
							"dataset": {
								"referenceName": "sql_DataMart_DimOnlineService",
								"type": "DatasetReference"
							},
							"name": "sinkDimOnlineService"
						},
						{
							"dataset": {
								"referenceName": "sql_DataMart_DimOnlineService",
								"type": "DatasetReference"
							},
							"name": "sinkDimOnlineServiceUpdate"
						}
					],
					"transformations": [
						{
							"name": "joinTmoviesStatus"
						},
						{
							"name": "addCreatedModified"
						},
						{
							"name": "addCreatedModified2"
						},
						{
							"name": "joinIdentifyUpdates"
						},
						{
							"name": "Rename"
						},
						{
							"name": "InsertOrUpdate"
						},
						{
							"name": "modifiedDateUpdate"
						},
						{
							"name": "updateRows"
						}
					],
					"scriptLines": [
						"source(output(",
						"          MovieId as integer,",
						"          MovieIdNK as integer,",
						"          Budget as integer,",
						"          HomepagePath as string,",
						"          Title as string,",
						"          OriginalTitle as string,",
						"          ReleaseDate as date,",
						"          Revenue as long,",
						"          Runtime as integer,",
						"          MovieStatusId as integer,",
						"          AvgVote as decimal(3,1),",
						"          CreatedDate as timestamp,",
						"          ModifiedDate as timestamp,",
						"          SrcFileName as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tMovies",
						"source(output(",
						"          MovieStatusId as integer,",
						"          MovieStatusName as string,",
						"          CreatedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tMoviesStatus",
						"source(output(",
						"          ServiceId as integer,",
						"          ServiceCode as string,",
						"          ServiceName as string,",
						"          CreatedDate as timestamp,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tOnlineService",
						"source(output(",
						"          ServiceKey as integer,",
						"          ServiceCode as string,",
						"          ServiceName as string,",
						"          CreatedDate as timestamp,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceDimOnlineService",
						"tMovies, tMoviesStatus join(tMovies@MovieStatusId == tMoviesStatus@MovieStatusId,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinTmoviesStatus",
						"joinTmoviesStatus derive(created_date = currentTimestamp(),",
						"          modified_date = currentTimestamp()) ~> addCreatedModified",
						"InsertOrUpdate@Insert derive(created_date_2 = currentTimestamp(),",
						"          modified_date_2 = currentTimestamp()) ~> addCreatedModified2",
						"tOnlineService, sourceDimOnlineService join(ServiceId == ServiceKey,",
						"     joinType:'outer',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinIdentifyUpdates",
						"joinIdentifyUpdates select(mapColumn(",
						"          source_ServiceId = ServiceId,",
						"          source_ServiceCode = tOnlineService@ServiceCode,",
						"          source_ServiceName = tOnlineService@ServiceName,",
						"          source_CreatedDate = tOnlineService@CreatedDate,",
						"          source_ModifiedDate = tOnlineService@ModifiedDate,",
						"          target_ServiceKey = ServiceKey,",
						"          target_ServiceCode = sourceDimOnlineService@ServiceCode,",
						"          target_ServiceName = sourceDimOnlineService@ServiceName,",
						"          target_CreatedDate = sourceDimOnlineService@CreatedDate,",
						"          target_ModifiedDate = sourceDimOnlineService@ModifiedDate",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> Rename",
						"Rename split(isNull(target_ServiceKey),",
						"     not(isNull(target_ServiceKey)) && (source_ServiceCode != target_ServiceCode || source_ServiceName != target_ServiceName),",
						"     disjoint: false) ~> InsertOrUpdate@(Insert, Update)",
						"InsertOrUpdate@Update derive(modified_column_update = currentTimestamp()) ~> modifiedDateUpdate",
						"modifiedDateUpdate alterRow(updateIf(true())) ~> updateRows",
						"addCreatedModified sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          MovieKey as integer,",
						"          MovieIdNK as integer,",
						"          Title as string,",
						"          ReleaseDate as date,",
						"          Runtime as integer,",
						"          MovieStatus as string,",
						"          CreatedDate as timestamp,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          MovieIdNK,",
						"          Title,",
						"          ReleaseDate,",
						"          Runtime,",
						"          MovieStatus = MovieStatusName,",
						"          CreatedDate = created_date,",
						"          ModifiedDate = modified_date",
						"     )) ~> sinkDimMovie",
						"addCreatedModified2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ServiceKey as integer,",
						"          ServiceCode as string,",
						"          ServiceName as string,",
						"          CreatedDate as timestamp,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          ServiceCode = source_ServiceCode,",
						"          ServiceName = source_ServiceName,",
						"          CreatedDate = created_date_2,",
						"          ModifiedDate = modified_date_2",
						"     )) ~> sinkDimOnlineService",
						"updateRows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ServiceKey as integer,",
						"          ServiceCode as string,",
						"          ServiceName as string,",
						"          CreatedDate as timestamp,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['ServiceKey'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          ServiceKey = source_ServiceId,",
						"          ServiceCode = source_ServiceCode,",
						"          ServiceName = source_ServiceName,",
						"          ModifiedDate = modified_column_update",
						"     )) ~> sinkDimOnlineServiceUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/M11_email')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "get_app_url",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": {
								"value": "@pipeline().globalParameters.secret_url",
								"type": "Expression"
							},
							"method": "GET",
							"headers": {},
							"body": "",
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "call_app",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "ExecuteCopy",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": {
								"value": "@activity('get_app_url').output.value",
								"type": "Expression"
							},
							"method": "POST",
							"headers": {},
							"body": {
								"value": "{    \n    \"message\":\"This is a custom dynamic message from pipeline Run with @{if(equals(activity('ExecuteCopy').status, 'Failed'), ' Error status during the process!', 'with Succeeded status!')}\"\n    ,\"pipelineStatus\":\"@{activity('ExecuteCopy').status}\"\n    ,\"dataFactoryName\":\"@{pipeline().DataFactory}\"\n    ,\"pipelineName\":\"@{activity('ExecuteCopy').PipelineName}\"\n    ,\"receiver\":\"@{pipeline().parameters.receiver}\"    \n}\n",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ExecuteCopy",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "get_app_url",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "copyFiles_M11",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"file_wildcard": "credits*"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"receiver": {
						"type": "string",
						"defaultValue": "leonardo_munoz@epam.com"
					}
				},
				"variables": {
					"myVar": {
						"type": "String"
					},
					"files": {
						"type": "Array",
						"defaultValue": [
							"credits*",
							"movies*",
							""
						]
					}
				},
				"folder": {
					"name": "M11"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-18T06:15:09Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/M7_masterProcess')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Incremental Copy",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "M7_incrementalCopy",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Insert and Populate",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Incremental Copy",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "M7_loadJsonToSQL",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Move Processed",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Insert and Populate",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "M7_moveProcessedFiles",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "M7"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-18T05:30:28Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/M8_PopulateDim_Tables')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "populate_dim_tables",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "M8_populate_dim_tables",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"tMovies": {},
									"tMoviesStatus": {},
									"tOnlineService": {},
									"sourceDimOnlineService": {},
									"sinkDimMovie": {},
									"sinkDimOnlineService": {},
									"sinkDimOnlineServiceUpdate": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "Azure-IR-M8",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "populate_fact_tables",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "populate_dim_tables",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "M8_populate_Fact_tables_2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"tOnlinePurchase": {},
									"DimOnlineService": {},
									"DimMovie": {},
									"sinkFactOnlinePurchase": {},
									"FactOnlinePurchaseMonthlySnapshot": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "Azure-IR-M8",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": [],
				"lastPublishTime": "2023-09-24T09:56:20Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/M8_populate_dim_tables')]",
				"[concat(variables('factoryId'), '/dataflows/M8_populate_Fact_tables_2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_ioo_MiddleLevel')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This pipeline will copy one batch of objects. The objects belonging to this batch will be copied parallelly.",
				"activities": [
					{
						"name": "DivideOneBatchIntoMultipleGroups",
						"description": "Divide objects from single batch into multiple sub parallel groups to avoid reaching the output limit of lookup activity.",
						"type": "ForEach",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@range(0, add(div(pipeline().parameters.SumOfObjectsToCopyForCurrentBatch, pipeline().parameters.MaxNumberOfObjectsReturnedFromLookupActivity),\n                    if(equals(mod(pipeline().parameters.SumOfObjectsToCopyForCurrentBatch, pipeline().parameters.MaxNumberOfObjectsReturnedFromLookupActivity), 0), 0, 1)))",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "GetObjectsPerGroupToCopy",
									"description": "Get objects (tables etc.) from control table required to be copied in this group. The order of objects to be copied following the TaskId in control table (ORDER BY [TaskId] DESC).",
									"type": "Lookup",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "SqlServerSource",
											"sqlReaderQuery": {
												"value": "WITH OrderedControlTable AS (\n                             SELECT *, ROW_NUMBER() OVER (ORDER BY [TaskId], [Id] DESC) AS RowNumber\n                             FROM @{pipeline().parameters.MainControlTableName}\n                             where TopLevelPipelineName = '@{pipeline().parameters.TopLevelPipelineName}'\n                             and TriggerName like '%@{pipeline().parameters.TriggerName}%' and CopyEnabled = 1)\n                             SELECT * FROM OrderedControlTable WHERE RowNumber BETWEEN @{add(mul(int(item()),pipeline().parameters.MaxNumberOfObjectsReturnedFromLookupActivity),\n                             add(mul(pipeline().parameters.SumOfObjectsToCopyForCurrentBatch, pipeline().parameters.CurrentSequentialNumberOfBatch), 1))}\n                             AND @{min(add(mul(int(item()), pipeline().parameters.MaxNumberOfObjectsReturnedFromLookupActivity), add(mul(pipeline().parameters.SumOfObjectsToCopyForCurrentBatch, pipeline().parameters.CurrentSequentialNumberOfBatch),\n                             pipeline().parameters.MaxNumberOfObjectsReturnedFromLookupActivity)),\n                            mul(pipeline().parameters.SumOfObjectsToCopyForCurrentBatch, add(pipeline().parameters.CurrentSequentialNumberOfBatch,1)), pipeline().parameters.SumOfObjectsToCopy)}",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "MetadataDrivenCopyTask_ioo_ControlDS",
											"type": "DatasetReference",
											"parameters": {}
										},
										"firstRowOnly": false
									}
								},
								{
									"name": "CopyObjectsInOneGroup",
									"description": "Execute another pipeline to copy objects from one group. The objects belonging to this group will be copied parallelly.",
									"type": "ExecutePipeline",
									"dependsOn": [
										{
											"activity": "GetObjectsPerGroupToCopy",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "MetadataDrivenCopyTask_ioo_BottomLevel",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"ObjectsPerGroupToCopy": {
												"value": "@activity('GetObjectsPerGroupToCopy').output.value",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"MaxNumberOfObjectsReturnedFromLookupActivity": {
						"type": "Int"
					},
					"TopLevelPipelineName": {
						"type": "String"
					},
					"TriggerName": {
						"type": "String"
					},
					"CurrentSequentialNumberOfBatch": {
						"type": "Int"
					},
					"SumOfObjectsToCopy": {
						"type": "Int"
					},
					"SumOfObjectsToCopyForCurrentBatch": {
						"type": "Int"
					},
					"MainControlTableName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "MetadataDrivenCopyTask_ioo_20230926"
				},
				"annotations": [],
				"lastPublishTime": "2023-09-27T04:33:44Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/masterProcess_Act5')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "executeCopy",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "copyFiles_Act2",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "executePopulation",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "executeCopy",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "loadToSQL_Act5",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "moveProcessedFiles",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "executePopulation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "moveProcessedFiles",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": [],
				"lastPublishTime": "2023-08-18T05:42:46Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DailyTrigger')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "IncrementalLoad_M6",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2023-08-29T06:25:00Z",
						"endTime": "2023-08-29T07:19:00Z",
						"timeZone": "UTC"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_ioo_TopLevel')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This pipeline will count the total number of objects (tables etc.) required to be copied in this run, come up with the number of sequential batches based on the max allowed concurrent copy task, and then execute another pipeline to copy different batches sequentially.",
				"activities": [
					{
						"name": "GetSumOfObjectsToCopy",
						"description": "Count the total number of objects (tables etc.) required to be copied in this run.",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": {
									"value": "SELECT count(*) as count FROM @{pipeline().parameters.MainControlTableName} where TopLevelPipelineName='@{pipeline().Pipeline}' and TriggerName like '%@{pipeline().TriggerName}%' and CopyEnabled = 1",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "MetadataDrivenCopyTask_ioo_ControlDS",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "CopyBatchesOfObjectsSequentially",
						"description": "Come up with the number of sequential batches based on the max allowed concurrent copy tasks, and then execute another pipeline to copy different batches sequentially.",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "GetSumOfObjectsToCopy",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@range(0, add(div(activity('GetSumOfObjectsToCopy').output.firstRow.count,\n                    pipeline().parameters.MaxNumberOfConcurrentTasks),\n                    if(equals(mod(activity('GetSumOfObjectsToCopy').output.firstRow.count,\n                    pipeline().parameters.MaxNumberOfConcurrentTasks), 0), 0, 1)))",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "CopyObjectsInOneBatch",
									"description": "Execute another pipeline to copy one batch of objects. The objects belonging to this batch will be copied parallelly.",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "MetadataDrivenCopyTask_ioo_MiddleLevel",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"MaxNumberOfObjectsReturnedFromLookupActivity": {
												"value": "@pipeline().parameters.MaxNumberOfObjectsReturnedFromLookupActivity",
												"type": "Expression"
											},
											"TopLevelPipelineName": {
												"value": "@{pipeline().Pipeline}",
												"type": "Expression"
											},
											"TriggerName": {
												"value": "@{pipeline().TriggerName}",
												"type": "Expression"
											},
											"CurrentSequentialNumberOfBatch": {
												"value": "@item()",
												"type": "Expression"
											},
											"SumOfObjectsToCopy": {
												"value": "@activity('GetSumOfObjectsToCopy').output.firstRow.count",
												"type": "Expression"
											},
											"SumOfObjectsToCopyForCurrentBatch": {
												"value": "@min(pipeline().parameters.MaxNumberOfConcurrentTasks, activity('GetSumOfObjectsToCopy').output.firstRow.count)",
												"type": "Expression"
											},
											"MainControlTableName": {
												"value": "@pipeline().parameters.MainControlTableName",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"MaxNumberOfObjectsReturnedFromLookupActivity": {
						"type": "Int",
						"defaultValue": 5000
					},
					"MaxNumberOfConcurrentTasks": {
						"type": "Int",
						"defaultValue": 20
					},
					"MainControlTableName": {
						"type": "String",
						"defaultValue": "test_control_table.MainControlTable_ioo"
					}
				},
				"folder": {
					"name": "MetadataDrivenCopyTask_ioo_20230926"
				},
				"annotations": [
					"MetadataDrivenSolution"
				],
				"lastPublishTime": "2023-09-27T04:33:45Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/MetadataDrivenCopyTask_ioo_MiddleLevel')]"
			]
		}
	]
}